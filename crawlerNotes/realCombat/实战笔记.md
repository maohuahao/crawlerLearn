## 网易云请求表单加密

主要方法就是扣去`js`加密代码，然后通过python执行`js`代码获取加密后的参数，在进行提交请求。

```js
目标网址：https://music.163.com/weapi/song/enhance/player/url/v1?csrf_token=
加密的参数：params、encSecKey
结果：获取音乐链接
```

### 问题

通过node环境运行`js`代码时，能够获取正确的加密参数（长度为256）。但是通过python的`pyexecjs`库运行得到的长度不对，并且提交请求后不会得到任何返回值。之后，根据网上资料了解到python在执行一些具有位运算的`js`代码时可能产生错误。所以选择直接使用python原生的`os`或subprocess库来执行`js`代码，使用这种方式的执行效率也比第三方的库要快得多。

### 使用方法

1. 首先电脑环境要安装`nodejs`

2. 通过`os.popen`执行node调用`js`代码

```python
import os
data = os.popen(node js代码 参数1 参数2 ...).readlines() # 返回一个列表根据你的在js代码中输出来默认会个每个输出加上一个换行，需要去掉
```

传入的参数前两个是node命令的路径和执行的js代码的绝对路径，需要进行处理，如下

```js
var arguments = process.argv.splice(2) // 通过数组方式获取参数
```

## 五矿

代码通过`webpack`打包，不采用口袋吗的方式，采用查找加密方式，通过`javascript`第三方包`node-encrypt-js`进行长明文`rsa`加密。其中使用其它第三方包显示加密参数过长不能实现，如`jsencrypt`。

```
目标网址：https://ec.minmetals.com.cn/open/homepage/zbs/by-lx-page
公钥来源网址：https://ec.minmetals.com.cn/open/homepage/public
加密参数：param
```

具体加密代码：

```js
let JSEncrypt = require('node-encrypt-js')

let encrypt = new JSEncrypt();

function getRsa(public_key, data){
    encrypt.setPublicKey(public_key);
    return encrypt.encryptLong(data);
}
```

## 极简壁纸
难点：代码大量混淆，无法通过搜索一些关键字的办法获取信息。所以这里调用堆栈信息查看加密或解密的关键点。
### 目标
```
目标：获取网页中的壁纸的详细链接。
网址：https://api.zzzmh.cn/bz/v3/getData
请求方式：post
提交的数据格式：request payload (json格式)
解密方式：暂时没有看出
解密的手段：通过扣js的方式
```
### 解密js代码
由于解密js代码太长，就不进行展示了。注意点：浏览器自带函数atob（作用：对base64编码进行解密）可是通过补环境的方式使该方法能够调用或使用nodejs自带的atob方法。
补环境的方式：
```js
var window = global;
```
### python实现
```python
import requests  
import execjs  
from fake_useragent import UserAgent  
  
user_agent = UserAgent()  
  
headers = {  
    'User-Agent': user_agent.random  
}  
  
  
class MiniWallpaper():  
    payload = {  
        "size": 24,  
        "sort": 0,  
        "category": 0,  
        "resolution": 0,  
        "color": 0,  
        "categoryId": 0,  
        "ratio": 0  
    }  
  
    def __init__(self, url: str):  
        self.ctx = None  
        self.result = None  
        self.url = url  
  
    # 初始化解密模块  
    def init_decrypt(self):  
        with open('12.极简壁纸.js', 'r') as f:  
            js = f.read()  
        self.ctx = execjs.compile(js)  
  
    # 获取加密数据  
    def get_data(self, page: int) -> str:  
        # requests.post(url=self.url, headers=headers, data=data) 请求返回的结果：{"msg":"未知异常，请联系管理员","result":{},"code":500}  
        self.payload.update({'current':page})  
        response = requests.post(url=self.url, headers=headers, json=self.payload)  
        self.result = response.json()['result']  
  
    def run(self):  
        self.init_decrypt()  
        self.get_data(1)  
  
        print(self.ctx.call('decrypt', self.result))  
  
  
if __name__ == '__main__':  
  
    url = 'https://api.zzzmh.cn/bz/v3/getData'  
    crawler_wallpaper = MiniWallpaper(url)  
    crawler_wallpaper.run()
```





## 热搜时光机
### 目标
```bash
目的：获取热搜的相关信息
网站：https://www.weibotop.cn/2.0/
```
### 分析结果
#### 1 过反调式
debugger 代码是通过定时器函数调用回调函数中`Function('Function(arguments[0]+"bugger")()')("de", 0, 0, 0)`进行反调试的。针对这种情况有以下几种方式。
##### 1.1 定时器hook
直接在浏览器控制台粘贴此代码无法过掉debugger，原因是：打开控制台后定时器就创建了一个子线程用于运行定时器中的回调函数，已经在内存中存在了，所以没有效果，而`fiddler Classic`的注入是在加载浏览器页面就执行了，所在之后定时器就是用的注入的定时器。可以通过`Fiddler Classic`安装编程猫插件进行hook注入定时器hook就是以下代码即可过掉反调式，之后就能正常调试了。
```js
var setInterval_ = setInterval
setInterval = function (func, time){
	console.log(func.toString());
	if(func.toString().includes('bugger')) {
		return function () {}; 
	} 
	return setInterval_(func, time)
}
```
##### 1.2 Function hook
使用Function这种方式的执行函数和eval执行函数的方法差不多。所以可以根据效仿hook eval的方式对Function 进行hook。代码如下：
```js
var function_ = Function;
Function = function(func){
				if(func.toString().includes('bugger')){
					return function(){};
				}else{
					return function_(func);
				}
			}
```
在控制台中注入hook的方式，是不能通过刷新浏览器进行调式的。因为一旦重新刷新浏览器，浏览器就会重新加载所有资源。之前的注入就没有效果了，所以只能通过触发请求的方式进行调试。比如当前网站我们可以通过切换时间触犯请求。
##### 1.3 ReRes本地替换
将触发`debugger`的资源文件进行另存为本地文件。在此之前要先下载好ReRes浏览器插件。也可以使用本地替换的方式，浏览器自带的功能。
将文件保存在本地后，找到执行`debugger`的地方将`bugger`和`de`变成空字符串。
在ReRes插件添加规则。刷新浏览器打开控制台就可以正常调试了。
#### 2 解密
观察响应体内容，尝试通过搜索大法进行查找。根据响应体的加密方式，可以使用JSON.parse关键字进行查找。在查找过程中会找到有关AES的字符串，此时我们就可以通过断点进行查看是否为解密的函数。最终找到解密函数h()，之后可以通过js中ecrypt-js库进行解密操作，再通过python请求获取加密内容，利用execjs第三方库调用js代码进行解密。